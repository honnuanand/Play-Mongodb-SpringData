package controllers;

import models.Person;
import mongoproxy.MongoConfiguration;
import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;
import org.springframework.data.mongodb.core.MongoOperations;
import play.mvc.Controller;
import play.mvc.Result;

import javax.inject.Named;
import javax.inject.Singleton;

/**
 * The main set of web services.
 */
@Named
@Singleton
public class Application extends Controller {

   // private final PersonRepository personRepository;

    // We are using constructor injection to receive a repository to support our desire for immutability.
    //@Inject
//    public Application(final PersonRepository personRepository) {
//        //this.personRepository = personRepository;
//
//
//    }

    public Result index() {

        // For fun we save a new person and then find that one we've just saved. The id is auto generated by
        // the db so we know that we're round-tripping to the db and back in order to demonstrate something
        // interesting. Spring Data takes care of transactional concerns and the following code is all
        // executed on the same thread (a requirement of the JPA entity manager).
        ApplicationContext ctx =
                new AnnotationConfigApplicationContext(MongoConfiguration.class);
        MongoOperations mongoOperation = (MongoOperations) ctx.getBean("mongoTemplate");
        //final Person savedPerson = personRepository.save(person);

        //final Person retrievedPerson = personRepository.findOne(savedPerson.id);

        // Deliver the index page with a message showing the id that was generated.
        mongoOperation.save(new Person("ABCDEF", "password123"));
        mongoOperation.save(new Person("ABCDEJ", "password123"));
        mongoOperation.save(new Person("ABCDEK", "password123"));

        return ok(views.html.index.render("Found id: " //retrievedPerson.id
                + " of person/people"));



    }
}
